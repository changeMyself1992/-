<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>

  <style>
    .box {
      width: 400px;
      display: flex;
    }

    .box1 {
      width: 400px;
      background-color: aqua;
      flex-shrink: 1;
    }

    .box2 {
      width: 400px;
      background-color: aquamarine;
      flex-shrink: 3;
    }
  </style>
</head>

<body>
  <div class="box">
    <di class="box1">1</di>
    <di class="box2">2</di>
  </div>

  <script>
    /*****作用域chuan和宏任务**************************start***/
    // let 的作用域再循环里面，每次循环都是一个新得变量，所以打印出来是01234
    // for (let i = 0; i < 5; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 100);
    // }
    // var 有变量提升，这里面打印的是一个变量100毫秒足够for循环走完了,而且最后一步i++也会执行，所以输出是5
    // for (var i = 0; i < 5; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 100);
    // }
    /*****作用域和宏任务**************************end***/

    /*****promiseAll实现**************************start***/
    // function promiseAll(promiseArray) {
    //     return new Promise((reslove, reject) => {
    //         const count = 0
    //         const arrayValue = new Array(promiseArray.length)
    //         promiseArray.forEach(async (promise, index) => {
    //             promise().then(res => {
    //                 count += 1
    //                 arrayValue[index] = res
    //                 if (count === promiseArray.length) {
    //                     reslove(arrayValue)
    //                 }
    //             }).catch(err => {
    //                 reject(err)
    //             })
    //         })
    //     })
    // }
    /*****promiseAll实现**************************end***/

    /*****数组扁平化**************************start***/
    // const array = [1, [2, [3, [4, 5]]], 6]
    // console.log(JSON.stringify(array).replace(/(\[|\])/g, '').split(","))

    // function fun (params) {
    //   let result = []
    //   if (Array.isArray(params)) {
    //     for (let i = 0; i < params.length; i++) {
    //       const element = params[i]
    //       if (Array.isArray(element)) {
    //         result = [...result, ...fun(element)]
    //       } else {
    //         result.push(element)
    //       }
    //     }
    //   }
    //   console.log(result)
    //   return result
    // }
    // let array1 = fun([1, [2, [3, [4, 5]]], 6])
    // console.log(array1)
    /*****数组扁平化**************************end***/

    /*****闭包**************************start***/
    // function demo() {
    //     let a = 100
    //     return function () {
    //         console.log(a)
    //     }
    // }
    // demo()()
    /*****闭包**************************end***/

    /*****宏任务微任务**************************start***/
    // console.log(1)
    // setTimeout(() => {
    //     console.log(2)
    //     new Promise((resolve) => {
    //         console.log(3)
    //         resolve(4)
    //     }).then((res) => {
    //         console.log(res)
    //     })
    //     console.log(5)
    // }, 0)

    // new Promise((resolve) => {
    //     console.log(6)
    //     resolve(7)
    // }).then((res) => {
    //     console.log(res)
    // })
    // console.log(8)
    /*****宏任务微任务**************************end***/

    /*****宏任务微任务又一道面试题**************************start***/
    // async function async1 () {
    //   console.log('async1 start')
    //   await async2()
    //   console.log('async1 end')
    // }
    // async function async2 () {
    //   console.log('async2')
    //   // 注意注意！！！async await实质只是promise.then 的语法糖，带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象，如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装！！！！
    // }

    // console.log('script start')
    // setTimeout(function () {
    //   console.log('setTimeout')
    // }, 0)
    // async1()
    // new Promise(function (resolve) {
    //   console.log('promise1')
    //   resolve()
    // }).then(function () {
    //   console.log('promise2')
    // })
    // console.log('script end')

    // // 结果
    // // ('script start')
    // // ('async1 start')
    // // ('async2')
    // // ('promise1')
    // // ('script end')
    // // ('async1 end')
    // // ('promise2')
    // // ('setTimeout')
    /*****宏任务微任务又一道面试题**************************end***/

    /*****Promise面试题**************************end***/
    // .then里面进行return 是在给下一个.then传参
    // handleValidator() {
    //   return Promise.all([eventTitleCheck, indexCheck, dimCheck, hiveDataSourceCheck, basicFormCheck])
    //     .then((res) => {
    //       console.log('第一次：', res);
    //       return '1111';
    //     })
    //     .then(res => {
    //       console.log('第二次：', res);// 会打印1111
    //       return '2222';
    //     })
    //     .catch(() => {
    //       // 处理验证失败的情况
    //     });
    // }
    /*****Promise面试题**************************end***/


    /*****判断数组深度**************************start***/
    // const list = [1, 3, 3, [4, 6, 7, [5, 6, 7, 43, [23, 4]]]]
    // function countFun (array) {
    //   let newCount = 0
    //   if (Array.isArray(array)) {
    //     newCount += 1
    //     for (let i = 0; i < array.length; i++) {
    //       const element = array[i]
    //       if (Array.isArray(element)) {
    //         newCount += countFun(element, newCount)
    //       }
    //     }
    //   }
    //   return newCount
    // }
    // const num = countFun(list)
    // console.log(num)

    // console.log('[1, 3, 3, [4, 6, 7, [5, 6, 7, 43, [23, 4]]]]'.match(/\[/g).length)
    /*****判断数组深度**************************end***/

    /*****es5原型继承**************************start***/
    // 申明一个父类，并且绑定一个原型方法
    // function SupperType(name) {
    //     console.log(1111)
    //     this.name = name
    //     this.colors = ['red', 'blue', 'green']
    // }
    // SupperType.prototype.sayName = function () {
    //     console.log(this.name)
    // }

    // // 申明一个子类，并在子类内部执行SupperType方法
    // function SubType(name, age) {
    //     SupperType.call(this, name)
    //     this.age = age
    // }
    // SubType.prototype = new SupperType();

    // var a1 = new SubType("张三", 28)
    // console.log(a1)
    // console.log(a1.sayName())
    /*****es5原型继承**************************end***/

    /*****正则练习**************************start***/
    // let template = `<div>{{ name }}<span>{{ age }}</span><div>`
    // `<div>singh<span>27</span><div>`

    // const data = { name: 'singh', age: 27 }
    // const matchArray = template.match(/\{\{(.*?)\}\}/g)
    // const keys = Object.keys(data)
    // for (let i = 0; i < keys.length; i++) {
    //   const key = keys[i]
    //   for (let i = 0; i < matchArray.length; i++) {
    //     const matchItem = matchArray[i]
    //     if (matchItem.includes(key)) {
    //       template = template.replace(matchItem, data[key])
    //     }
    //   }
    // }
    // console.log(template)

    /*****正则练习**************************end***/

    /*****手动实现防抖**************************start***/
    // function debounce (fun, wait) {
    //   let timer = null
    //   return e => {
    //     if (timer) {
    //       clearTimeout(timer)
    //     }
    //     timer = setTimeout(() => {
    //       fun(e)
    //     }, wait)
    //   }
    // }

    // const fun = debounce(name => {
    //   console.log(name)
    // }, 3000)

    // for (let i = 0; i < 10; i++) {
    //   fun(i)
    // }
    /*****手动实现防抖**************************end***/

    /*****手动实节流**************************start***/
    // function throttle (func, wait) {
    //   let old = 0
    //   return e => {
    //     let now = Date.now()
    //     if (now - old > wait) {
    //       func(e)
    //       old = now
    //     }
    //   }
    // }
    /*****手动实现节流**************************end***/

    /*****Promise.race**************************start***/
    // // 同时发起几个异步请求，谁先有结果就拿谁的
    // function resolveTimeout1 () {
    //   return new Promise(resolve => setTimeout(() => resolve(1111), 1000))
    // }
    // function resolveTimeout2 () {
    //   return new Promise(resolve => setTimeout(() => resolve(2222), 2000))
    // }
    // async function fun () {
    //   const res = await Promise.race([resolveTimeout1(), resolveTimeout2()])
    //   console.log(res)
    // }
    // fun()
    /*****Promise.race**************************end***/

    /*****手写深拷贝**************************start***/
    // let obj1 = {
    //   name: 'xxx',
    //   sex: '男',
    //   like: ['红色', '蓝色'],
    //   book: {
    //     title: 'js程序',
    //     price: '88'
    //   }
    // }
    // function deepClone (obj = {}) {
    //   /** obj是null, 或者不是对象和数组，直接返回；对象和数组需要进一步拷贝对象的属性、数组的元素，通过递归实现 */
    //   if (typeof obj !== 'object' || obj == null) {
    //     return obj
    //   }

    //   // 初始化返回结果
    //   let result
    //   if (obj instanceof Array) {
    //     result = []
    //   } else {
    //     result = {}
    //   }

    //   for (const key in obj) {
    //     // 保证key不是从原型取得的属性
    //     if (Object.hasOwnProperty.call(obj, key)) {
    //       // 递归调用
    //       result[key] = deepClone(obj[key])
    //     }
    //   }

    //   return result
    // }

    // function deepClone (obj = {}) {
    //   let newObj = null
    //   if (Array.isArray(obj)) {
    //     newObj = []
    //     for (let i = 0; i < obj.length; i++) {
    //       const element = obj[i]
    //       if (
    //         typeof element === 'string' ||
    //         typeof element === 'number' ||
    //         typeof element === 'boolean'
    //       ) {
    //         newObj.push(element)
    //       } else {
    //         newObj[i] = deepClone(element)
    //       }
    //     }
    //   } else if (obj.constructor === Object) {
    //     newObj = {}
    //     Object.keys(obj).forEach(key => {
    //       if (
    //         typeof obj[key] === 'string' ||
    //         typeof obj[key] === 'number' ||
    //         typeof obj[key] === 'boolean'
    //       ) {
    //         newObj[key] = obj[key]
    //       } else {
    //         newObj[key] = deepClone(obj[key])
    //       }
    //     })
    //   }
    //   return newObj
    // }
    // console.log(deepClone(obj1))
    /*****手写深拷贝**************************end***/

    /*****继承**************************start***/
    // class Polygon {
    //   constructor (height, width) {
    //     this.name = 'Polygon'
    //     this.height = height
    //     this.width = width
    //   }
    //   tagVal = 'ups'
    //   fun1 (params) {}
    // }
    // console.log(11111,new Polygon(1,2))

    // class Square extends Polygon {
    //   constructor (length) {
    //     super(length, length)
    //     // 注意：必须比 'this.' 先调用 super()
    //     this.name = 'Square'
    //   }
    //   fun2 (params) {}
    // }
    // const square = new Square(20)
    // console.log(square)
    /*****继承**************************end***/

    /*****手写reduce**************************start***/
    // const array1 = [1, 2, 3, 4]
    // const count = array1.reduce((value1, value2, index) => {
    //   console.log(value1, value2, index)
    //   return value1 + value2
    // }, 0)
    // console.log(count)

    // function reduce1 (array, callFun, init = 0) {
    //   let result = init
    //   for (let i = 0; i < array.length; i++) {
    //     result = callFun(result, array[i])
    //   }
    //   return result
    // }
    // const count = reduce1([1, 2, 3, 4], (v1, v2) => v1 + v2, 0)
    // console.log(count)
    /*****手写reduce**************************end***/

    /*****数字千分位**************************start***/
    // const str = 12345678.98765
    // // 1.使用api
    // console.log(str.toLocaleString())

    // // 2. 手写  12,345,678.988
    // function numberFormt (num) {
    //   // 1. 使用正则检验 入参是否是 正的 小数和整数类型
    //   if (true) {
    //     let numStr = String(num)
    //     if (numStr.includes('.')) {
    //       numStr=Number(numStr).toFixed(3)
    //       const array1 = numStr.split('.')

    //       let str = ''
    //       const array2 = array1[0].match(/(\d)/g).reverse()
    //       for (let i = 0; i < array2.length; i++) {
    //         if ((i + 1) % 3 === 0) {
    //           str = ',' + String(array2[i]) + str
    //         } else {
    //           str = String(array2[i]) + str
    //         }
    //       }
    //       return str + `.${array1[1]}`
    //     } else {
    //       // 12345678
    //       let array = numStr.match(/(\d)/g).reverse() // [1,2,3,4,5,6,7,8 ]  [8,7,6,5,4,3,2,1 ]
    //       let str = ''
    //       for (let i = 0; i < array.length; i++) {
    //         if ((i + 1) % 3 === 0) {
    //           str = ',' + String(array[i]) + str
    //         } else {
    //           str = String(array[i]) + str
    //         }
    //       }
    //       return str
    //     }
    //   } else {
    //     return undefined
    //   }
    // }
    // console.log(numberFormt(12345678.98765))
    // console.log(numberFormt(12345678))

    /*****数字千分位**************************end***/

    /*****自定义事件实现监听pushState**************************start***/

    // function createHistoryEvent (type) {
    //   var fn = history[type]
    //   return function () {
    //     // 这里的 arguments 就是调用 pushState 时的三个参数集合
    //     var res = fn.apply(this, arguments)
    //     let e = new Event(type)
    //     e.arguments = arguments
    //     window.dispatchEvent(e)
    //   }
    // }
    // history.pushState = createHistoryEvent('pushState')
    // window.addEventListener('pushState', function (event) {
    //   // { type: 'pushState', arguments: [...], target: Window, ... }
    //   debugger
    //   console.log(event)
    // })
    // const state = { page_id: 1, user_id: 5 }
    // history.pushState(state, '', 'https://www.baidu.com/121323')

    /*****自定义事件实现监听pushState**************************end***/



    /*****最长连续序列**************************start***算法题******************/

    // // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
    // var longestConsecutive = function (nums) {
    //   // 1.先升序,尽可能的让它连续
    //   for (let i = 0; i < nums.length - 1; i++) {
    //     for (let j = i + 1; j < nums.length; j++) {
    //       if (nums[i] > nums[j]) {
    //         const temp = nums[i];
    //         nums[i] = nums[j]
    //         nums[j] = temp
    //       }
    //     }
    //   }
    //   console.log('升序后的nums:', nums)

    //   // 2. 创建一个二维数组，把nums的每个元素都包起来
    //   let newNums = [];
    //   for (let i = 0; i < nums.length; i++) {
    //     newNums.push([nums[i]])
    //   }

    //   // 3. 然后进行内外俩层的循环，把所有的连续序列 都存起来
    //   for (let j = 0; j < newNums.length; j++) {
    //     for (let i = 0; i < nums.length; i++) {
    //       if (newNums[j][newNums[j].length - 1] + 1 === nums[i]) {
    //         newNums[j].push(nums[i])
    //       }
    //     }
    //   }
    //   console.log("newNums:", newNums)
    //   // 4. 在二维数组中找到最长的数组，进行打印
    //   console.log("返回的连续最长数组:", newNums.sort((array1, array2) => {
    //     return array2.length - array1.length
    //   })[0])
    // };
    // // longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])// 期望结果是 [0, 1, 2, 3, 4, 5, 6, 7, 8]
    // // longestConsecutive([100, 4, 200, 1, 3, 2])// 期望结果是 [1, 2, 3, 4]
    // longestConsecutive([0, 1, 2, 100, 101, 102, 103, 104])// 期望结果是 [100,101,102,103,104]

    /*****最长连续序列**************************end***算法题******************/

    /*****数组合并区间**************************start***算法题******************/
    // 道算法题 数组合并区间，[[1,3],[2,6],[8,10],[15,18]] 这种数组，将重叠的部分合并成一个。
    /*****数组合并区间**************************end***算法题******************/

    /*****求连续子数组最大和**************************start***算法题******************/

    // 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    // 子数组 是数组中的一个连续部分。

    // 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
    // 输出：6
    // 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

    // 解题思路，前一个元素和后一个元素相加，然后和后一个元素比大小，求出当局的最大和,全局最大和就是所有当局最大和最大的那一个！！
    // 那么
    // -2+1=-1   (-2,1) 1
    // 1+-3=-2   (-2,-3) -2
    // -2+4=2    (2,4) 4
    // 4+-1=3    (3,-1) 3
    // 3+2=5     (5,2) 5
    // 5+1=6     (6,1) 6
    // 6+-5=1    (1,-5) 1
    // 1+4=5     (5,4) 5


    var maxSubArray = function (nums) {
      let globmax = nums[0];// 全局的最大和
      let currMax = nums[0]; // 当局的最大和
      let prevMax = null; // 当局最大和 和 和元素相加的结果
      let array = [];
      let index = -1;
      for (i = 1; i < nums.length; i++) {
        if (typeof prevMax === 'number') {
          if (currMax + nums[i] > prevMax) {
            if (index === -1) {
              array.push(nums[i])
            }
            if (index !== -1 && index + 1 === i) {
              array.push(nums[i])
            }
            console.log('index', index)
            console.log('i', i)
            index = i
          }
        }

        prevMax = currMax + nums[i];
        currMax = Math.max(prevMax, nums[i]);
        globmax = Math.max(currMax, globmax);
      }
      console.log(111111111)
      console.log(globmax)
      console.log(array)
    };
    maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]);

    /*****求连续子数组最大和**************************end***算法题******************/

    /*****降序**************************start***算法题******************/
    // const nums = [1, 3, 5, 7, 3, 0]
    // for (let i = 0; i < nums.length - 1; i++) {
    //   for (let j = i + 1; j < nums.length; j++) {
    //     if (nums[j] > nums[i]) {
    //       let temp = nums[i]
    //       nums[i] = nums[j]
    //       nums[j] = temp
    //     }
    //   }
    // }
    // console.log(nums)
    /*****降序**************************start***算法题******************/

    /*****递归**************************start***算法题******************/
    // // 给你一个字节点的key，把它对应的祖辈节点的key都找出来

    // function findParentKey(tree, targetKey, parentPath = []) {
    //   for (let node of tree) {
    //     if (node.key === targetKey) {
    //       // 返回最后一个父节点即为一级节点的key
    //       return parentPath;
    //     }
    //     if (node.data && node.data.initialData && node.data.initialData.children) {
    //       // 在递归调用时将当前节点加入父节点路径
    //       let result = findParentKey(node.data.initialData.children, targetKey, [...parentPath, node.key]);
    //       console.log(1111, result)
    //       if (result !== null) {
    //         return result;
    //       }
    //     }
    //   }
    //   return null;
    // }

    // const treeData = [
    //   {
    //     "key": 1,
    //     "data": {
    //       "initialData": {
    //         "children": [
    //           {
    //             "key": 2,
    //             "data": {
    //               "fileData": {},
    //               "initialData": {
    //                 "children": [
    //                   {
    //                     "key": 5,
    //                     "data": {
    //                       "fileData": {},
    //                       "initialData": {
    //                       }
    //                     }
    //                   },
    //                 ]
    //               }
    //             }
    //           },
    //           {
    //             "key": 3,
    //             "data": {
    //               "fileData": {},
    //               "initialData": {}
    //             }
    //           }
    //         ]
    //       }
    //     }
    //   },
    //   {
    //     "key": 4,
    //     "data": {
    //       "fileData": {},
    //       "initialData": {}
    //     }
    //   }
    // ];
    // const parentKey = findParentKey(treeData, 3);
    // console.log(222, parentKey);
    /*****递归**************************end***算法题******************/

    /*****俩数之和**************************end***算法题******************/
    //给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
    // var twoSum = function (nums, target) {
    //   for (let i = 0; i < nums.length; i++) {

    //     for (let j = i + 1; j < nums.length; j++) {
    //       if (nums[i] + nums[j] === target) {
    //         return [i, j]
    //       }
    //     }
    //   }
    // };
    // // const indexs = twoSum([2, 7, 11, 15], 9);
    // // const indexs = twoSum([3,2,4], 6);
    // const indexs = twoSum([3, 3], 6);
    // console.log(indexs)
    /*****俩数之和**************************end***算法题******************/

  </script>
</body>

</html>