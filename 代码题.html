<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <script>
    /*****作用域chuan和宏任务**************************start***/
    // let 的作用域再循环里面，每次循环都是一个新得变量，所以打印出来是01234
    // for (let i = 0; i < 5; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 100);
    // }
    // var 有变量提升，这里面打印的是一个变量100毫秒足够for循环走完了,而且最后一步i++也会执行，所以输出是5
    // for (var i = 0; i < 5; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 100);
    // }
    /*****作用域和宏任务**************************end***/

    /*****promiseAll实现**************************start***/
    // function promiseAll(promiseArray) {
    //     return new Promise((reslove, reject) => {
    //         const count = 0
    //         const arrayValue = new Array(promiseArray.length)
    //         promiseArray.forEach(async (promise, index) => {
    //             promise().then(res => {
    //                 count += 1
    //                 arrayValue[index] = res
    //                 if (count === promiseArray.length) {
    //                     reslove(arrayValue)
    //                 }
    //             }).catch(err => {
    //                 reject(err)
    //             })
    //         })
    //     })
    // }
    /*****promiseAll实现**************************end***/

    /*****数组扁平化**************************start***/
    // const array = [1, [2, [3, [4, 5]]], 6]
    // console.log(JSON.stringify(array).replace(/(\[|\])/g, '').split(","))

    // function fun (params) {
    //   let result = []
    //   if (Array.isArray(params)) {
    //     for (let i = 0; i < params.length; i++) {
    //       const element = params[i]
    //       if (Array.isArray(element)) {
    //         result = [...result, ...fun(element)]
    //       } else {
    //         result.push(element)
    //       }
    //     }
    //   }
    //   console.log(result)
    //   return result
    // }
    // let array1 = fun([1, [2, [3, [4, 5]]], 6])
    // console.log(array1)
    /*****数组扁平化**************************end***/

    /*****闭包**************************start***/
    // function demo() {
    //     let a = 100
    //     return function () {
    //         console.log(a)
    //     }
    // }
    // demo()()
    /*****闭包**************************end***/

    /*****宏任务微任务**************************start***/
    // console.log(1)
    // setTimeout(() => {
    //     console.log(2)
    //     new Promise((resolve) => {
    //         console.log(3)
    //         resolve(4)
    //     }).then((res) => {
    //         console.log(res)
    //     })
    //     console.log(5)
    // }, 0)

    // new Promise((resolve) => {
    //     console.log(6)
    //     resolve(7)
    // }).then((res) => {
    //     console.log(res)
    // })
    // console.log(8)
    /*****宏任务微任务**************************end***/

    /*****宏任务微任务又一道面试题**************************start***/
    // async function async1 () {
    //   console.log('async1 start')
    //   await async2()
    //   console.log('async1 end')
    // }
    // async function async2 () {
    //   console.log('async2')
    //   // 注意注意！！！async await实质只是promise.then 的语法糖，带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象，如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装！！！！
    // }

    // console.log('script start')
    // setTimeout(function () {
    //   console.log('setTimeout')
    // }, 0)
    // async1()
    // new Promise(function (resolve) {
    //   console.log('promise1')
    //   resolve()
    // }).then(function () {
    //   console.log('promise2')
    // })
    // console.log('script end')

    // // 结果
    // // ('script start')
    // // ('async1 start')
    // // ('async2')
    // // ('promise1')
    // // ('script end')
    // // ('async1 end')
    // // ('promise2')
    // // ('setTimeout')
    /*****宏任务微任务又一道面试题**************************end***/

    /*****Promise面试题**************************end***/
    // .then里面进行return 是在给下一个.then传参
    // handleValidator() {
    //   return Promise.all([eventTitleCheck, indexCheck, dimCheck, hiveDataSourceCheck, basicFormCheck])
    //     .then((res) => {
    //       console.log('第一次：', res);
    //       return '1111';
    //     })
    //     .then(res => {
    //       console.log('第二次：', res);// 会打印1111
    //       return '2222';
    //     })
    //     .catch(() => {
    //       // 处理验证失败的情况
    //     });
    // }
    /*****Promise面试题**************************end***/


    /*****判断数组深度**************************start***/
    // const list = [1, 3, 3, [4, 6, 7, [5, 6, 7, 43, [23, 4]]]]
    // function countFun (array) {
    //   let newCount = 0
    //   if (Array.isArray(array)) {
    //     newCount += 1
    //     for (let i = 0; i < array.length; i++) {
    //       const element = array[i]
    //       if (Array.isArray(element)) {
    //         newCount += countFun(element, newCount)
    //       }
    //     }
    //   }
    //   return newCount
    // }
    // const num = countFun(list)
    // console.log(num)

    // console.log('[1, 3, 3, [4, 6, 7, [5, 6, 7, 43, [23, 4]]]]'.match(/\[/g).length)
    /*****判断数组深度**************************end***/

    /*****es5原型继承**************************start***/
    // 申明一个父类，并且绑定一个原型方法
    // function SupperType(name) {
    //     console.log(1111)
    //     this.name = name
    //     this.colors = ['red', 'blue', 'green']
    // }
    // SupperType.prototype.sayName = function () {
    //     console.log(this.name)
    // }

    // // 申明一个子类，并在子类内部执行SupperType方法
    // function SubType(name, age) {
    //     SupperType.call(this, name)
    //     this.age = age
    // }
    // SubType.prototype = new SupperType();

    // var a1 = new SubType("张三", 28)
    // console.log(a1)
    // console.log(a1.sayName())
    /*****es5原型继承**************************end***/

    /*****正则练习**************************start***/
    // let template = `<div>{{ name }}<span>{{ age }}</span><div>`
    // `<div>singh<span>27</span><div>`

    // const data = { name: 'singh', age: 27 }
    // const matchArray = template.match(/\{\{(.*?)\}\}/g)
    // const keys = Object.keys(data)
    // for (let i = 0; i < keys.length; i++) {
    //   const key = keys[i]
    //   for (let i = 0; i < matchArray.length; i++) {
    //     const matchItem = matchArray[i]
    //     if (matchItem.includes(key)) {
    //       template = template.replace(matchItem, data[key])
    //     }
    //   }
    // }
    // console.log(template)

    /*****正则练习**************************end***/

    /*****手动实现防抖**************************start***/
    // function debounce (fun, wait) {
    //   let timer = null
    //   return e => {
    //     if (timer) {
    //       clearTimeout(timer)
    //     }
    //     timer = setTimeout(() => {
    //       fun(e)
    //     }, wait)
    //   }
    // }

    // const fun = debounce(name => {
    //   console.log(name)
    // }, 3000)

    // for (let i = 0; i < 10; i++) {
    //   fun(i)
    // }
    /*****手动实现防抖**************************end***/

    /*****手动实节流**************************start***/
    // function throttle (func, wait) {
    //   let old = 0
    //   return e => {
    //     let now = Date.now()
    //     if (now - old > wait) {
    //       func(e)
    //       old = now
    //     }
    //   }
    // }
    /*****手动实现节流**************************end***/

    /*****Promise.race**************************start***/
    // // 同时发起几个异步请求，谁先有结果就拿谁的
    // function resolveTimeout1 () {
    //   return new Promise(resolve => setTimeout(() => resolve(1111), 1000))
    // }
    // function resolveTimeout2 () {
    //   return new Promise(resolve => setTimeout(() => resolve(2222), 2000))
    // }
    // async function fun () {
    //   const res = await Promise.race([resolveTimeout1(), resolveTimeout2()])
    //   console.log(res)
    // }
    // fun()
    /*****Promise.race**************************end***/

    /*****手写深拷贝**************************start***/
    // let obj1 = {
    //   name: 'xxx',
    //   sex: '男',
    //   like: ['红色', '蓝色'],
    //   book: {
    //     title: 'js程序',
    //     price: '88'
    //   }
    // }
    // function deepClone (obj = {}) {
    //   /** obj是null, 或者不是对象和数组，直接返回；对象和数组需要进一步拷贝对象的属性、数组的元素，通过递归实现 */
    //   if (typeof obj !== 'object' || obj == null) {
    //     return obj
    //   }

    //   // 初始化返回结果
    //   let result
    //   if (obj instanceof Array) {
    //     result = []
    //   } else {
    //     result = {}
    //   }

    //   for (const key in obj) {
    //     // 保证key不是从原型取得的属性
    //     if (Object.hasOwnProperty.call(obj, key)) {
    //       // 递归调用
    //       result[key] = deepClone(obj[key])
    //     }
    //   }

    //   return result
    // }

    // function deepClone (obj = {}) {
    //   let newObj = null
    //   if (Array.isArray(obj)) {
    //     newObj = []
    //     for (let i = 0; i < obj.length; i++) {
    //       const element = obj[i]
    //       if (
    //         typeof element === 'string' ||
    //         typeof element === 'number' ||
    //         typeof element === 'boolean'
    //       ) {
    //         newObj.push(element)
    //       } else {
    //         newObj[i] = deepClone(element)
    //       }
    //     }
    //   } else if (obj.constructor === Object) {
    //     newObj = {}
    //     Object.keys(obj).forEach(key => {
    //       if (
    //         typeof obj[key] === 'string' ||
    //         typeof obj[key] === 'number' ||
    //         typeof obj[key] === 'boolean'
    //       ) {
    //         newObj[key] = obj[key]
    //       } else {
    //         newObj[key] = deepClone(obj[key])
    //       }
    //     })
    //   }
    //   return newObj
    // }
    // console.log(deepClone(obj1))
    /*****手写深拷贝**************************end***/

    /*****继承**************************start***/
    // class Polygon {
    //   constructor (height, width) {
    //     this.name = 'Polygon'
    //     this.height = height
    //     this.width = width
    //   }
    //   tagVal = 'ups'
    //   fun1 (params) {}
    // }
    // console.log(11111,new Polygon(1,2))

    // class Square extends Polygon {
    //   constructor (length) {
    //     super(length, length)
    //     // 注意：必须比 'this.' 先调用 super()
    //     this.name = 'Square'
    //   }
    //   fun2 (params) {}
    // }
    // const square = new Square(20)
    // console.log(square)
    /*****继承**************************end***/

    /*****手写reduce**************************start***/
    // const array1 = [1, 2, 3, 4]
    // const count = array1.reduce((value1, value2, index) => {
    //   console.log(value1, value2, index)
    //   return value1 + value2
    // }, 0)
    // console.log(count)

    // function reduce1 (array, callFun, init = 0) {
    //   let result = init
    //   for (let i = 0; i < array.length; i++) {
    //     result = callFun(result, array[i])
    //   }
    //   return result
    // }
    // const count = reduce1([1, 2, 3, 4], (v1, v2) => v1 + v2, 0)
    // console.log(count)
    /*****手写reduce**************************end***/

    /*****数字千分位**************************start***/
    // const str = 12345678.98765
    // // 1.使用api
    // console.log(str.toLocaleString())

    // // 2. 手写  12,345,678.988
    // function numberFormt (num) {
    //   // 1. 使用正则检验 入参是否是 正的 小数和整数类型
    //   if (true) {
    //     let numStr = String(num)
    //     if (numStr.includes('.')) {
    //       numStr=Number(numStr).toFixed(3)
    //       const array1 = numStr.split('.')

    //       let str = ''
    //       const array2 = array1[0].match(/(\d)/g).reverse()
    //       for (let i = 0; i < array2.length; i++) {
    //         if ((i + 1) % 3 === 0) {
    //           str = ',' + String(array2[i]) + str
    //         } else {
    //           str = String(array2[i]) + str
    //         }
    //       }
    //       return str + `.${array1[1]}`
    //     } else {
    //       // 12345678
    //       let array = numStr.match(/(\d)/g).reverse() // [1,2,3,4,5,6,7,8 ]  [8,7,6,5,4,3,2,1 ]
    //       let str = ''
    //       for (let i = 0; i < array.length; i++) {
    //         if ((i + 1) % 3 === 0) {
    //           str = ',' + String(array[i]) + str
    //         } else {
    //           str = String(array[i]) + str
    //         }
    //       }
    //       return str
    //     }
    //   } else {
    //     return undefined
    //   }
    // }
    // console.log(numberFormt(12345678.98765))
    // console.log(numberFormt(12345678))

    /*****数字千分位**************************end***/

    /*****自定义事件实现监听pushState**************************start***/

    // function createHistoryEvent (type) {
    //   var fn = history[type]
    //   return function () {
    //     // 这里的 arguments 就是调用 pushState 时的三个参数集合
    //     var res = fn.apply(this, arguments)
    //     let e = new Event(type)
    //     e.arguments = arguments
    //     window.dispatchEvent(e)
    //   }
    // }
    // history.pushState = createHistoryEvent('pushState')
    // window.addEventListener('pushState', function (event) {
    //   // { type: 'pushState', arguments: [...], target: Window, ... }
    //   debugger
    //   console.log(event)
    // })
    // const state = { page_id: 1, user_id: 5 }
    // history.pushState(state, '', 'https://www.baidu.com/121323')

    /*****自定义事件实现监听pushState**************************end***/



    /*****最长连续序列**************************start***算法题******************/

    // // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
    // var longestConsecutive = function (nums) {
    //   // 1.先升序,尽可能的让它连续
    //   for (let i = 0; i < nums.length - 1; i++) {
    //     for (let j = i + 1; j < nums.length; j++) {
    //       if (nums[i] > nums[j]) {
    //         const temp = nums[i];
    //         nums[i] = nums[j]
    //         nums[j] = temp
    //       }
    //     }
    //   }
    //   console.log('升序后的nums:', nums)

    //   // 2. 创建一个二维数组，把nums的每个元素都包起来
    //   let newNums = [];
    //   for (let i = 0; i < nums.length; i++) {
    //     newNums.push([nums[i]])
    //   }

    //   // 3. 然后进行内外俩层的循环，把所有的连续序列 都存起来
    //   for (let j = 0; j < newNums.length; j++) {
    //     for (let i = 0; i < nums.length; i++) {
    //       if (newNums[j][newNums[j].length - 1] + 1 === nums[i]) {
    //         newNums[j].push(nums[i])
    //       }
    //     }
    //   }
    //   console.log("newNums:", newNums)
    //   // 4. 在二维数组中找到最长的数组，进行打印
    //   console.log("返回的连续最长数组:", newNums.sort((array1, array2) => {
    //     return array2.length - array1.length
    //   })[0])
    // };
    // // longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])// 期望结果是 [0, 1, 2, 3, 4, 5, 6, 7, 8]
    // // longestConsecutive([100, 4, 200, 1, 3, 2])// 期望结果是 [1, 2, 3, 4]
    // longestConsecutive([0, 1, 2, 100, 101, 102, 103, 104])// 期望结果是 [100,101,102,103,104]

    /*****最长连续序列**************************end***算法题******************/

    /*****数组合并区间**************************start***算法题******************/

    // // 道算法题 数组合并区间，[[1,3],[2,6],[8,10],[15,18]] 这种数组，将重叠的部分合并成一个。
    // // 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
    // // 输出：[[1,6],[8,10],[15,18]]
    // // 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]

    // function mergeIntervals(intervals) {
    //   // 1.对区间数组进行左端点升序
    //   intervals.sort((a, b) => { return a[0] - b[0] })
    //   let currentInterval = intervals[0];
    //   let meaged = [];
    //   for (let i = 1; i < intervals.length; i++) {
    //     const nextInterval = intervals[i];
    //     // 如果下一个区间的左端点，小于等于上一个区间的右端点，说明这个俩区间是重叠的, 合并之后存起来
    //     if (nextInterval[0] <= currentInterval[1]) {
    //       currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
    //       meaged.push(currentInterval)
    //     } else {
    //       // 否则的话说明不重叠，直接把下一个区间存起来，更新当前区间都继续循环
    //       meaged.push(nextInterval)
    //       currentInterval = nextInterval;
    //     }
    //   }
    //   return meaged
    // }

    // const intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
    // console.log(mergeIntervals(intervals)); // 输出：[[1,6],[8,10],[15,18]]

    /*****数组合并区间**************************end***算法题******************/

    /*****求连续子数组最大和**************************start***算法题******************/

    // // 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    // // 子数组 是数组中的一个连续部分。

    // // 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
    // // 输出：6
    // // 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

    // // 解题思路
    // // 1. 前一个元素和后一个元素相加，然后和后一个元素比大小，求出当局的最大和,全局最大和就是所有当局最大和最大的那一个！！
    // // 2. 最后一次给全局最大和赋值的时候，这个索引就是最大和子数组的结束索引
    // // 3. 最后一次当局最大和 和 当前元素相等的时候，这个索引就是最大和子数组的开始索引


    // // -2+1=-1   (-2,1)   当局的最大和1           1>-2===true   最大和1   结束索引1       (1===1)===true       开始索引1
    // // 1+-3=-2   (-2,-3)  当局的最大和-2         -2>1===false   最大和1                  (-2===-3)===false
    // // -2+4=2    (2,4)    当局的最大和4            4>1===true   最大和4   结束索引3       (4===4)===true       开始索引3
    // // 4+-1=3    (3,-1)   当局的最大和3           3>4===false   最大和4                  (3===-1)===false
    // // 3+2=5     (5,2)    当局的最大和5            5>4===true   最大和5   结束索引5       (5===2)===false
    // // 5+1=6     (6,1)    当局的最大和6            6>5===true   最大和5   结束索引6       (6===1)===false
    // // 6+-5=1    (1,-5)   当局的最大和1           1>6===false   最大和6                  (1===-5)===false
    // // 1+4=5     (5,4)    当局的最大和5            5>6===false  最大和6                  (5===)===fasle

    // function maxSubArray(nums) {
    //   let globalSum = nums[0];  // 全局最大和
    //   let currentSum = nums[0];  // 当局最大和
    //   let start = 0;  // 最大和子数组的起始索引
    //   let end = 0;  // 最大和子数组的结束索引

    //   for (let i = 1; i < nums.length; i++) {
    //     // 求出单局最大和
    //     currentSum = Math.max(nums[i], currentSum + nums[i]);
    //     // 如果当局最大和  大于 全局最大和
    //     if (currentSum > globalSum) {
    //       globalSum = currentSum;// 更新全局最大和
    //       end = i;// 最后一次给全局最大和赋值的时候，这个索引就是最大和子数组的结束索引
    //       if (4 === nums[i]) {
    //         start = i; // 最后一次当局最大和 和 当前元素相等的时候，这个索引就是最大和子数组的开始索引
    //       }
    //     }
    //   }
    //   console.log('全局最大和：', globalSum)
    //   console.log('连续子数组：', nums.slice(start, end + 1))// 最后直接切出来就行，注意slice方法，结束索引要加上1才会切到结束索引那一块
    // }
    // maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]);

    /*****求连续子数组最大和**************************end***算法题******************/

    /*****降序**************************start***算法题******************/
    // const nums = [1, 3, 5, 7, 3, 0]
    // for (let i = 0; i < nums.length - 1; i++) {
    //   for (let j = i + 1; j < nums.length; j++) {
    //     if (nums[j] > nums[i]) {
    //       let temp = nums[i]
    //       nums[i] = nums[j]
    //       nums[j] = temp
    //     }
    //   }
    // }
    // console.log(nums)
    /*****降序**************************start***算法题******************/

    /*****递归**************************start***算法题******************/
    // // 给你一个字节点的key，把它对应的祖辈节点的key都找出来

    // function findParentKey(tree, targetKey, parentPath = []) {
    //   for (let node of tree) {
    //     if (node.key === targetKey) {
    //       // 返回最后一个父节点即为一级节点的key
    //       return parentPath;
    //     }
    //     if (node.data && node.data.initialData && node.data.initialData.children) {
    //       // 在递归调用时将当前节点加入父节点路径
    //       let result = findParentKey(node.data.initialData.children, targetKey, [...parentPath, node.key]);
    //       console.log(1111, result)
    //       if (result !== null) {
    //         return result;
    //       }
    //     }
    //   }
    //   return null;
    // }

    // const treeData = [
    //   {
    //     "key": 1,
    //     "data": {
    //       "initialData": {
    //         "children": [
    //           {
    //             "key": 2,
    //             "data": {
    //               "fileData": {},
    //               "initialData": {
    //                 "children": [
    //                   {
    //                     "key": 5,
    //                     "data": {
    //                       "fileData": {},
    //                       "initialData": {
    //                       }
    //                     }
    //                   },
    //                 ]
    //               }
    //             }
    //           },
    //           {
    //             "key": 3,
    //             "data": {
    //               "fileData": {},
    //               "initialData": {}
    //             }
    //           }
    //         ]
    //       }
    //     }
    //   },
    //   {
    //     "key": 4,
    //     "data": {
    //       "fileData": {},
    //       "initialData": {}
    //     }
    //   }
    // ];
    // const parentKey = findParentKey(treeData, 3);
    // console.log(222, parentKey);
    /*****递归**************************end***算法题******************/

    /*****俩数之和**************************end***算法题******************/
    //给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
    // var twoSum = function (nums, target) {
    //   for (let i = 0; i < nums.length; i++) {

    //     for (let j = i + 1; j < nums.length; j++) {
    //       if (nums[i] + nums[j] === target) {
    //         return [i, j]
    //       }
    //     }
    //   }
    // };
    // // const indexs = twoSum([2, 7, 11, 15], 9);
    // // const indexs = twoSum([3,2,4], 6);
    // const indexs = twoSum([3, 3], 6);
    // console.log(indexs)
    /*****俩数之和**************************end***算法题******************/

    /*****轮转数组**************************start***算法题******************/

    // // 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
    // // 输入: nums = [1,2,3,4,5,6,7], k = 3
    // // 输出: [5,6,7,1,2,3,4]

    // // [1,2,3,4,5,6,7]
    // // [[],[1,2,3,4,5,6,7],[]]   1步 [[7],[1,2,3,4,5,6]]
    // // [[],[1,2,3,4,5,6,7],[]]   2步 [[6,7],[1,2,3,4,5]]
    // // [[],[1,2,3,4,5,6,7],[]]   2步 [[5,6,7],[1,2,3,4]]
    // function carouselArray(nums, step) {
    //   let carouse = [[], nums];
    //   for (let i = 0; i < step; i++) {
    //     if(carouse[1].length===0){ // 如果检测到最后一个数组长度为空了 需要反转
    //       carouse.reverse()
    //     }
    //     const lastNum = carouse[1].pop(); // pop() 方法用于删除数组的最后一个元素并返回删除的元素。
    //     carouse[0].unshift(lastNum); // unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
    //   }
    //   console.log(carouse);
    //   console.log([...carouse[0],...carouse[1]]);
    // }
    // carouselArray([1, 2, 3, 4, 5, 6, 7], 3) // [5,6,7,1,2,3,4]
    // // carouselArray([-1, -100, 3, 99], 2) // [5,6,7,1,2,3,4]

    /*****轮转数组**************************end***算法题******************/


    /*****除自身以外数组的乘积**************************start***算法题******************/

    // // 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
    // // 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

    // // 输入: nums = [1,2,3,4]
    // // 输出: [24,12,8,6]

    // function createProductArray(nums) {
    //   let productArray = [];
    //   for (let i = 0; i < nums.length; i++) {
    //     const newArray = nums.filter((num, index) => {
    //       return index !== i
    //     })

    //     let total = 1
    //     newArray.forEach(num => {
    //       total = Math.abs(total * num)
    //     });
    //     productArray.push(total)
    //   }
    //   console.log(productArray)
    // }
    // createProductArray([1, 2, 3, 4]) // [24,12,8,6]
    // // createProductArray([-1, 1, 0, -3, 3]) // [0,0,9,0,0]

    /*****除自身以外数组的乘积**************************end***算法题******************/


    /*****除自身以外数组的乘积**************************start***算法题******************/
    // 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

    // 示例 1：
    // 输入：nums = [1,2,0]
    // 输出：3

    // 示例 2：
    // 输入：nums = [3,4,-1,1]
    // 输出：2

    // 示例 3：
    // 输入：nums = [7,8,9,11,12]
    // 输出：1

    // 实在理解不了，死记住步骤
    // 1. 第一次遍历，将所有小于等于0和大于数组长度的数都改为 数组长度加1
    // 2. 第二次遍历，把元素取绝对值变成数字x,如果x小于等于数组长度，那么执行公式转为负数 nums[x-1]=-Math.abs(nums[x-1])
    // 3. 第三次遍历，找到第一个正数，返回索引+1，这样就找出了没有出现的最小正整数
    // 4. 如果第三步，没有返回，那么就返回数组长度+1

    // function minxMissInt(nums) {
    //   let n = nums.length
    //   for (let i = 0; i < nums.length; i++) {
    //     if (nums[i] <= 0 || nums[i] > n) {
    //       nums[i] = n + 1
    //     }
    //   }

    //   for (let i = 0; i < nums.length; i++) {
    //     const x = Math.abs(nums[i]);
    //     if (x < nums.length) {
    //       nums[x - 1] = -Math.abs(nums[x - 1])
    //     }
    //   }

    //   for (let i = 0; i < nums.length; i++) {
    //     if (nums[i] > 0) return i + 1
    //   }

    //   return n+1
    // }

    // // console.log(minxMissInt([1, 2, 0])); // 输出 3
    // // console.log(minxMissInt([3, 4, -1, 1])); // 输出 2
    // // console.log(minxMissInt([7, 8, 9, 11, 12])); // 输出 1

    /*****除自身以外数组的乘积**************************start***算法题******************/


    /*****和为k的子数组**************************start***算法题******************/

    // 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
    // 子数组是数组中元素的连续非空序列。

    // 示例 1：
    //   输入：nums = [1,1,1], k = 2
    //   输出：2

    // 示例 2：
    //   输入：nums = [1,2,3], k = 3
    //   输出：2

    function subarraySum(nums, sum) {
      let temp = nums[0]
      let count = 0
      for (let i = 1; i < nums.length; i++) {
        if (temp + nums[i] === sum || nums[i] === sum) {
          count += 1
        }
        temp = nums[i]
      }
      return count
    }
    console.log(subarraySum([1, 1, 1], 2)) //输出：2
    console.log(subarraySum([1, 2, 3], 3)) //输出：2

    function subarraySum(nums, k) {
      let count = 0;
      let sum = 0;
      const map = new Map();
      map.set(0, 1);

      for (let i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (map.has(sum - k)) {
          count += map.get(sum - k);
        }
        if (map.has(sum)) {
          map.set(sum, map.get(sum) + 1);
        } else {
          map.set(sum, 1);
        }
      }

      return count;
    }

    // 示例 1
    console.log(subarraySum([1, 1, 1], 2)); // 输出: 2

    // 示例 2
    console.log(subarraySum([1, 2, 3], 3)); // 输出: 2



    /*****和为k的子数组**************************end***算法题******************/

  </script>
</body>

</html>